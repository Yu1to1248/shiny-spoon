<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>モンスト風反射ゲーム（複数ウェーブ＆エフェクト付き）</title>
  <style>
    canvas {
      background: #eef;
      display: block;
      margin: auto;
      border: 2px solid #333;
      touch-action: none;
    }
    #clearMessage {
      text-align: center;
      font-size: 32px;
      font-weight: bold;
      color: green;
      display: none;
      margin: 1rem auto;
      user-select: none;
    }
    #waveMessage {
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      color: navy;
      margin: 0.5rem auto;
      user-select: none;
    }
    #retryBtn {
      display: none;
      margin: 0.5rem auto;
      padding: 0.5rem 1rem;
      font-size: 18px;
      cursor: pointer;
      user-select: none;
      border-radius: 4px;
      border: 1px solid #333;
      background: #ddd;
      color: #222;
    }
    #retryBtn:hover {
      background: #bbb;
    }
  </style>
</head>
<body>
  <div id="waveMessage"></div>
  <div id="clearMessage">ステージクリア！</div>
  <button id="retryBtn">リトライ</button>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const clearMessage = document.getElementById('clearMessage');
    const waveMessage = document.getElementById('waveMessage');
    const retryBtn = document.getElementById('retryBtn');

    // 画像読み込み（画像ない場合は円表示）
    const playerImg = new Image();
    const enemyImg = new Image();
    playerImg.src = 'player.png';
    enemyImg.src = 'enemy.png';

    const player = {
      x: 200,
      y: 500,
      radius: 16,
      vx: 0,
      vy: 0,
      isMoving: false,
    };

    // 各ウェーブ（ステージ）ごとの敵配置・設定
    const waves = [
      [
        { x: 80, y: 120, radius: 20, hp: 1, maxHp: 1 },
        { x: 300, y: 140, radius: 22, hp: 2, maxHp: 2 },
      ],
      [
        { x: 60, y: 100, radius: 22, hp: 2, maxHp: 2 },
        { x: 200, y: 150, radius: 25, hp: 3, maxHp: 3 },
        { x: 340, y: 180, radius: 22, hp: 2, maxHp: 2 },
      ],
      [
        { x: 100, y: 130, radius: 25, hp: 4, maxHp: 4 },
        { x: 300, y: 130, radius: 25, hp: 4, maxHp: 4 },
        { x: 200, y: 170, radius: 28, hp: 5, maxHp: 5 },
      ],
    ];

    let currentWave = 0;
    let enemies = [];
    let damageTexts = [];
    let hitEffects = [];

    let touchStart = null;

    function resetPlayer() {
      player.x = 200;
      player.y = 500;
      player.vx = 0;
      player.vy = 0;
      player.isMoving = false;
    }

    function loadWave(n) {
      enemies = waves[n].map(e => ({ ...e }));
      damageTexts = [];
      hitEffects = [];
      clearMessage.style.display = 'none';
      retryBtn.style.display = 'none';
      waveMessage.textContent = `WAVE ${n + 1} / ${waves.length}`;
      resetPlayer();
    }

    canvas.addEventListener('pointerdown', e => {
      if (player.isMoving) return;
      const rect = canvas.getBoundingClientRect();
      touchStart = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    });

    canvas.addEventListener('pointerup', e => {
      if (!touchStart || player.isMoving) return;
      const rect = canvas.getBoundingClientRect();
      const end = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };

      const dx = touchStart.x - end.x;
      const dy = touchStart.y - end.y;
      const power = Math.min(Math.sqrt(dx * dx + dy * dy), 100) / 5;
      const angle = Math.atan2(dy, dx);

      player.vx = Math.cos(angle) * power;
      player.vy = Math.sin(angle) * power;
      player.isMoving = true;
    });

    function update() {
      if (player.isMoving) {
        player.x += player.vx;
        player.y += player.vy;

        // 壁反射
        if (player.x - player.radius < 0 || player.x + player.radius > canvas.width) {
          player.vx *= -1;
          player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
        }
        if (player.y - player.radius < 0 || player.y + player.radius > canvas.height) {
          player.vy *= -1;
          player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        }

        // 減速
        player.vx *= 0.98;
        player.vy *= 0.98;
        if (Math.abs(player.vx) < 0.1 && Math.abs(player.vy) < 0.1) {
          player.vx = 0;
          player.vy = 0;
          player.isMoving = false;
        }

        // 敵当たり判定
        enemies.forEach(enemy => {
          if (enemy.hp <= 0) return;
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < player.radius + enemy.radius) {
            enemy.hp--;
            damageTexts.push({ x: enemy.x, y: enemy.y, value: '-1', alpha: 1 });
            hitEffects.push(createHitEffect(enemy.x, enemy.y));
            player.vx *= -1;
            player.vy *= -1;
          }
        });
      }

      // ダメージテキスト更新
      damageTexts.forEach(text => {
        text.y -= 1;
        text.alpha -= 0.03;
      });
      while (damageTexts.length > 0 && damageTexts[0].alpha <= 0) {
        damageTexts.shift();
      }

      // ヒットエフェクト更新
      hitEffects.forEach(effect => {
        effect.particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.04;
          p.alpha = p.life / p.maxLife;
        });
        effect.particles = effect.particles.filter(p => p.life > 0);
        effect.life -= 0.04;
      });
      hitEffects = hitEffects.filter(e => e.life > 0);

      // ステージクリア判定
      if (enemies.every(e => e.hp <= 0)) {
        currentWave++;
        if (currentWave < waves.length) {
          waveMessage.textContent = `WAVE ${currentWave} クリア！ 3秒後に次のウェーブへ`;
          player.isMoving = false;
          // 3秒後に次のウェーブを読み込む
          setTimeout(() => {
            loadWave(currentWave);
          }, 3000);
        } else {
          clearMessage.style.display = 'block';
          waveMessage.textContent = '';
          retryBtn.style.display = 'inline-block';
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 敵描画
      enemies.forEach(enemy => {
        if (enemy.hp <= 0) return;
        if (enemyImg.complete && enemyImg.naturalWidth !== 0) {
          ctx.drawImage(enemyImg, enemy.x - enemy.radius, enemy.y - enemy.radius, enemy.radius * 2, enemy.radius * 2);
        } else {
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
          ctx.fillStyle = 'green';
          ctx.fill();
        }
        // HPバー
        ctx.fillStyle = 'black';
        ctx.fillRect(enemy.x - 20, enemy.y - enemy.radius - 12, 40, 5);
        ctx.fillStyle = 'red';
        ctx.fillRect(enemy.x - 20, enemy.y - enemy.radius - 12, 40 * (enemy.hp / enemy.maxHp), 5);
      });

      // プレイヤー描画
      if (playerImg.complete && playerImg.naturalWidth !== 0) {
        ctx.drawImage(playerImg, player.x - player.radius, player.y - player.radius, player.radius * 2, player.radius * 2);
      } else {
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
      }

      // ダメージテキスト描画
      damageTexts.forEach(text => {
        ctx.fillStyle = `rgba(255,0,0,${text.alpha})`;
        ctx.font = 'bold 16px sans-serif';
        ctx.fillText(text.value, text.x - 10, text.y);
      });

      // ヒットエフェクト描画（パーティクル）
      hitEffects.forEach(effect => {
        // フラッシュ
        ctx.fillStyle = `rgba(255,255,255,${Math.min(0.6, effect.life * 2)})`;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, 20, 0, Math.PI * 2);
        ctx.fill();

        // パーティクル
        effect.particles.forEach(p => {
          ctx.fillStyle = `rgba(255, 255, 0, ${p.alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      });
    }

    function createHitEffect(x, y) {
      const particles = [];
      for (let i = 0; i < 10; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 1;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          maxLife: 1,
          alpha: 1,
        });
      }
      return { x, y, life: 1, particles };
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // 初期ウェーブ読み込み
    loadWave(currentWave);

    retryBtn.onclick = () => {
      currentWave = 0;
      loadWave(currentWave);
      clearMessage.style.display = 'none';
      retryBtn.style.display = 'none';
    };

    // 画像読み込み後にゲーム開始（なくても円描画で動く）
    let imagesLoaded = 0;
    function checkImagesLoaded() {
      imagesLoaded++;
      if (imagesLoaded >= 2) {
        loop();
      }
    }
    playerImg.onload = checkImagesLoaded;
    enemyImg.onload = checkImagesLoaded;
    // 画像が無い場合も3秒後に開始
    setTimeout(() => {
      if (imagesLoaded < 2) {
        loop();
      }
    }, 3000);
  </script>
</body>
</html>
